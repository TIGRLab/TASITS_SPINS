---
title: "R Notebook"
output: html_notebook
---

```{r}
#Summary: TASIT-S is a shorter form of TASIT. Both tests have 3 subtests. These substests contain items whose scores are added together to come up with total scores for the subtest. In order to prove the validity of TASIT-S, the scores from the three subtests in TASIT-S were correlated with the scores of the subtests from the original TASIT. The scores of controls and patients were put together in TASIT:S and were compared with the scores of controls and pateints in the  original TASIT. Later on, these same correaltions between subtests from TASIT:S vs TASIT were made, but only looking at the scores of controls in TASIT:S vs TASIT and then only looking at the scores of patients in TASIT:S vs TASIT

# Also, just wanted to reiterate following our discussion yesterday, that what we're most interested in with these different analyses is determining whether we are capturing the same 'information' of interest using the TASIT-S as we have been with the full TASIT in people with SSDs (and across SSDs and healthy controls). We're doing this the same way they did in the Honan paper, using correlations between the orig and TASIT-S scores to see how similar (how highly correlated) they are, as well as correlations with other measures we know to be related to the original full TASIT, including social cognitive measures most importantly, as well as neurocog measures, clinical measures (SANS especially), and functioning measures (BSFS and QLS). We are doing the t-tests between groups to see if the orig TASIT and TASIT-S scores show similar differentiation between our case and control groups (i.e., are similar group differences seen with the orig TASIT and TASIT-S scores, based on the p values and effect sizes)
```



```{r}
library(tidyverse)
#Inputting the necessary datasets into your script
spinsdata <- read.csv(file="/projects/aolorunsola/TASITS_SPINS/data/raw/spins_tasit_data_06-23-2023.csv",header=TRUE)

colnames(spinsdata)

#Refining original spinsdata to only include participants that are in another dataset (called "spins_df") that contains some other social cognitive measures that are not TASIT tests. Essentially removing participant data that isn't useful to us. We only want participants that have both TASIT data and the other social cognitive measures because we will be making correlations using both TASIT data and other social cognitive measures)
#Loading in dataset that contains other social cognitive measures (other SPINS soc/cog data):
spins_df <- read.csv("/projects/loliver/SPINS_PLS_Conn/data/processed/spins_behav_data_full_03-03-2022.csv", header = T, stringsAsFactors = F)
# remove MPRC site participants as they do not have the individual TASIT items captured. 
spins_df <- spins_df[spins_df$site!="mrc",]
#Translates to: remove all participants whose site (column) is mrc. 

# subset/filter "spinsdata" dataset to drop participants that are not in cleaned spins_df: 
spinsdata <- spinsdata[spinsdata$record_id %in% spins_df$record_id,]
#This subsets the "spinsdata" dataframe to only include participants who were in the "spinsdf" dataframe. I'm assuming this is done so that we have two datasets: "spinsdata" and "spins_df", both of which include the same patients. Making sure we have participants that have multiple test scores is important, as we will be able to use these participants for correlations using many different variables.


print(spinsdata)
dim(spinsdata)
#We have now removed useless data (data of participants that are NOT included in the "spins_df" dataset), and our "spinsdata" dataset has been filtered correctly. It originally had 389 participants. The data now has 317 participants, as the participant's whose results were no longer useful were removed.

#This is to show you which participants contained some missing scores (from variables/columns 16-258, which are the TASIT columns):
spinsdata[!complete.cases(spinsdata[ ,16:258]), 16:258]
#Code wasn't useful because it told you that 123 participants had missing data, which is false.


#Code at the chunk at the bottom of this entire script allowed you to find out which participants had missing TASIT data. Now, remove those patients from the spinsdata:

spinsdata <- spinsdata[!(spinsdata$record_id == "SPN01_ZHP_0094" | spinsdata$record_id == "SPN01_ZHP_0140" | spinsdata$record_id == "SPN01_ZHP_0144" | spinsdata$record_id == "SPN01_CMH_0010" | spinsdata$record_id == "SPN01_CMH_0045" | spinsdata$record_id == "SPN01_CMH_0161" | spinsdata$record_id == "SPN01_CMP_0183" | spinsdata$record_id == "SPN01_ZHH_0059" | spinsdata$record_id == "SPN01_ZHP_0092" | spinsdata$record_id == "SPN01_ZHP_0100" | spinsdata$record_id == "SPN01_ZHP_0103" | spinsdata$record_id == "SPN01_ZHP_0110" | spinsdata$record_id == "SPN01_ZHP_0164" | spinsdata$record_id == "SPN01_ZHP_0172"),]


#Therefore, the new filtered spinsdata should have (317)-(14) participants = 303. However, Lindsay's data seems to not have removed these participants. Therefore don't need to set this refined dataset to "spinsdata", as this would make our correlations different from Lindsay's. Therefore, just turn above code into a note. Or, can set it to a new variable if you'd like.
#After running this command however, my correlations are all the same as Lindsay's. I'll remove the command for now however using #.
```



```{r}
#Tasit 1 items (The items included: 3 happy, 4 revolted, 9 revolted, 13 neutral, 14 anxious, 18 angry, 19 neutral,22 revolted, 25 anxious, and 27 sad from the original TASIT)
#re-coding items to correct or incorrect (for questions that had multiple choices, but only one right answer). This is done so that we can calculate a total score for TASIT-1 by adding the item scores together
#"ifelse" is the function that makes it correct or incorrect.
# 3 happy - example: for this item (video clip), we are making it so that only one answer is correct. "tasit_3_olivia" just represents that this is item #3 from the original TASIT 1, and the actor is Olivia. When we said "3 happy" abobe, this is just to say that the answer for this item is happy, and it is the 3rd item in the original TASIT list.
#Note: when you run an item in the console without setting any of its scores to an ifelse function, the table you see will be the scores that have not been re-coded/adjusted.
#Also note: when you run an item in the console, the table you see = the scores from all of the patients in the study for that item.

#Renaming all of the TASIT variables to have names that match the TASIT-S variables (so that correlations make sense wheen looked at)
#Had to make this code a comment after I replaced everything as if it remained in the script, the variables would be replacing themselves and everything would get messed up
#spinsdata <- spinsdata %>% 
  #rename("tasit_part1_total" = "tasit_correct_total",
         #"tasit_part2_sinc" = "tasit_part2_total_sincere",
         #"tasit_part2_total" = "tasit_part2_grandtotal",
         #"tasit_part3_lies" = "tasit_part3_grandtotal_lies",
         #"tasit_part3_sarc" = "tasit_part3_grandtotal_sarcasm")

print(spinsdata)
spinsdata
colnames(spinsdata)
# edit in the location where you created these variables:
# "tasit_part2_sarc" = "tasit_part2_sarc"
# "tasit_part3_sarc" = "tasit_part3_grandtotal_sarc"

spinsdata$tasit_3_olivia <- ifelse(spinsdata$tasit_3_olivia == 1, 1, 0)
#4 revolted
spinsdata$tasit_4_olivia <- ifelse(spinsdata$tasit_4_olivia == 7, 1, 0)
#9 revolted
spinsdata$tasit_9_mm <- ifelse(spinsdata$tasit_9_mm == 7, 1, 0)
#13 neutral
spinsdata$tasit_13_mz <- ifelse(spinsdata$tasit_13_mz == 3, 1, 0)
#14 anxious
spinsdata$tasit_14_mick <- ifelse(spinsdata$tasit_14_mick == 6, 1, 0)
#18 angry
spinsdata$tasit_18_michael <- ifelse(spinsdata$tasit_18_michael == 5, 1, 0)
#19 neutral
spinsdata$tasit_19_ruth <- ifelse(spinsdata$tasit_19_ruth == 3, 1, 0)
#22 revolted
spinsdata$tasit_22_michael<- ifelse(spinsdata$tasit_22_michael == 7, 1, 0)
#25 anxious
spinsdata$tasit_25_km<- ifelse(spinsdata$tasit_25_km == 6, 1, 0)
#27 sad
spinsdata$tasit_27_michael<- ifelse(spinsdata$tasit_27_michael == 4, 1, 0) 
```



```{r}
#rowSums (used to add scores from the multiple tests (items) within Tasit-S:1 so that we can get a total subscore for the subtest, TASIT-S:1)
spinsdata$tasits_part1_total <- rowSums(spinsdata[,c("tasit_3_olivia", "tasit_4_olivia", "tasit_9_mm", "tasit_13_mz", "tasit_14_mick", "tasit_18_michael", "tasit_19_ruth", "tasit_22_michael", "tasit_25_km", "tasit_27_michael")]) 

#we make correlations between variables because if variables in the short form correlate highly with variables in the long form, they essentially show the same thing.
#correlation between TASIT-S:1 and original TASIT:1:
cor(na.omit(spinsdata[c("tasit_part1_total", "tasits_part1_total")]))
#can also use "rcorr" function (for multiple variables)
#correlation that produces p values:
cor.test(spinsdata$tasit_part1_total, spinsdata$tasits_part1_total) 
#correlation using spearman's coefficients:
cor.test(spinsdata$tasit_part1_total, spinsdata$tasits_part1_total,
         method = "spearman", exact = FALSE)

#Note: correlations are not only made between subscores (which is seen in TASIT:S 2 and 3, but not 1. 1 only correlates the total scores. Correlations are also made between scores within the subscores - ex: TASIT:S-2's paradoxical sarcasm score correlated with the paradoxical score from the original TASIT:2. These are both scores within the sarcasm score.
```



```{r}
#For the original TASIT:1 total, the score is supposed to be the total positive emotions + the total negative emotions
#spinsdata$tasit_part1_total <- rowSums(spinsdata[,c("tasit_positive_total", "tasit_negative_total")]) 
#cor(na.omit(spinsdata[c("tasit_part1_total", "tasits_part1_total")]))
#Got a very low correlation here, so this way I calculated the TASIt:1 score must be incorrect
#checking something - to find out what the total score of TASIT actually is. Add up all of the item scores then correlate this new variable with "tasit_part1_total" variable. If there is a perfect correlation, then they must be the same thing
spinsdata$tasit_part1_total <- rowSums(spinsdata[,c("tasit_part1_happyscore", "tasit_part2_surprisedscore", "tasit_part3_neutralscore", "tasit_part4_sadscore", "tasit_part5_angryscore", "tasit_part6_anxiousscore", "tasit_part7_revoltedscore")]) 
cor(na.omit(spinsdata[c("tasit_part1_total", "tasit_part1_total")]))
#what I expected to happen is exactly what happened: the way that the "tasit_part1_total" variable was generated was by adding all of the item scores together (as seen by perfect correlation). Therefore we can just use the "tasit_part1_total" variable
```



```{r}
# Code for TASIT-S:2
# Make sure to use the totals of the items, as within TASIT-S:2 and TASIT-S:3, there are multiple variables for the items. We only need the ones that include "total" in their name.
# Tasit-2: For Sincere, a final four-item subtest was produced which included items 1, 4, 11, and 14 from the original TASIT. 
spinsdata$tasits_part2_sinc<- rowSums(spinsdata[,c("tasit_part2_1_weekend_away_total", "tasit_part2_4_lunch_total", "tasit_part2_11_tickets_total", "tasit_part2_14_shirt_total")])

#Tasit-2: For Sarcasm, a final five-item subtest was produced which included items 2, 5, 10, 13, and 15 from the original TASIT. 
spinsdata$tasits_part2_sarc<- rowSums(spinsdata[,c("tasit_part2_2_date_total", "tasit_part2_5_tie_total", "tasit_part2_10_movies_total", "tasit_part2_13_promotion_total", "tasit_part2_15_dress_total")])

#Summing the Sincere and Sarcasm scores to get a total TASIT-S:2 score
spinsdata$tasits_part2_total <- rowSums(spinsdata[,c("tasits_part2_sinc", "tasits_part2_sarc")]) 

#correlation between TASIT-S:2 and original TASIT:2 total scores:
cor(na.omit(spinsdata[c("tasit_part2_total", "tasits_part2_total")]))
#correlation that produces p values:
cor.test(spinsdata$tasit_part2_total, spinsdata$tasits_part2_total)
#Spearman's correlation coefficient
cor.test(spinsdata$tasit_part2_total, spinsdata$tasits_part2_total,
         method = "spearman", exact = FALSE)

#correlation between TASIT-S:2 sincere and TASIT:2 sincere
cor(na.omit(spinsdata[c("tasit_part2_sinc", "tasits_part2_sinc")]))
#correlation that produces p values:
cor.test(spinsdata$tasit_part2_sinc, spinsdata$tasits_part2_sinc)
#Spearman's correlation coefficient
cor.test(spinsdata$tasit_part2_sinc, spinsdata$tasits_part2_sinc,
         method = "spearman", exact = FALSE)

#correlation between TASIT-S:2 sarcasm and TASIT:2 sarcasm. But first, you need to code a total score for TASIT:2 sarcasm by adding the paradoxical and the simple sarcasm scores.
spinsdata$tasit_part2_sarc <- rowSums(spinsdata[,c("tasit_part2_total_p_sarcasm", "tasit_part2_total_s_sarcasm")]) 
cor(na.omit(spinsdata[c("tasit_part2_sarc", "tasits_part2_sarc")]))
#correlation that produces p values:
cor.test(spinsdata$tasit_part2_sarc, spinsdata$tasits_part2_sarc)
#Spearman's correlation coefficient
cor.test(spinsdata$tasit_part2_sarc, spinsdata$tasits_part2_sarc,
         method = "spearman", exact = FALSE)
```



```{r}
# Code for TASIT-S 3:

#For Lies, a final four-item subtest was produced which included items 7, 13, 15, and 16 from the original TASIT.
spinsdata$tasits_part3_lies <- rowSums(spinsdata[,c("tasit_part3_7_icecream_total_visual", "tasit_part3_13_moving_total_text", "tasit_part3_15_crossword_total_visual", "tasit_part3_16_enough_eat_total_text")])

#For Sarcasm, a final five-item subtest was produced which included items 2, 4, 9, 10, and 12 from the original TASIT. Person–item maps for the final solutions are shown in Figure 3.
spinsdata$tasits_part3_sarc <- rowSums(spinsdata[,c("tasit_part3_2_scribbling_total_visual", "tasit_part3_4_party_total_text", "tasit_part3_9_outfit_total_text", "tasit_part3_10_fat_total_text", "tasit_part3_12_bottle_total_visual")])

#Summing the Lies and Sarcasm scores to get a total TASIT-S:3 score
spinsdata$tasits_part3_total <- rowSums(spinsdata[,c("tasits_part3_lies", 'tasits_part3_sarc')])

#correlation between TASIT-S:3 and original TASIT:3:
#First need to add together the grandtotals of "sarcasm" scores and "lies" scores from original TASIT:3. Note - we didn't do this for TASIT:2 because the dataset seemed to already have a variable available for the TASIT:2 total score.
spinsdata$tasit_part3_total <- rowSums(spinsdata[,c("tasit_part3_lies", "tasit_part3_sarc")])
#correlating TASIT-S:3 with original TASIT:3 scores:
cor(na.omit(spinsdata[c("tasit_part3_total", "tasits_part3_total")]))
#correlation that produces p values:
cor.test(spinsdata$tasit_part3_total, spinsdata$tasits_part3_total)
#Spearman's correlation coefficient
cor.test(spinsdata$tasit_part3_total, spinsdata$tasits_part3_total,
         method = "spearman", exact = FALSE)

#Correlating "lies" scores
cor(na.omit(spinsdata[c("tasits_part3_lies", "tasit_part3_lies")]))
#correlation that produces p values:
cor.test(spinsdata$tasits_part3_lies, spinsdata$tasit_part3_lies)
#Spearman's correlation coefficient
cor.test(spinsdata$tasits_part3_lies, spinsdata$tasit_part3_lies,
         method = "spearman", exact = FALSE)


#Correlating "sarcasm" scores
cor(na.omit(spinsdata[c("tasits_part3_sarc", "tasit_part3_sarc")]))
#correlation that produces p values:
cor.test(spinsdata$tasits_part3_sarc, spinsdata$tasit_part3_sarc)
#Spearman's correlation coefficient
cor.test(spinsdata$tasits_part3_sarc, spinsdata$tasit_part3_sarc,
         method = "spearman", exact = FALSE)
```



```{r}
#So, in TASIT:S-1, we set all of our item scores to correct or incorrect, then we added all of our item scores for a total subtest score. For TASIT-S-2, we added the total scores for the sincere section of the test to get a total sincere score, then we did the same thing for the sarcastic score (=paradoxical sarcasm + simple sarcasm scores) to get a total sarcastic score. We then added the two together to get a total TASIT:S-2 score. For TASIT:S-3, a total lies score is calculated, as well as a sarcasm score to get the total TASIT:S-3 score.
#As you can see, the TASIT:S-1 scores were not split up. All of the item scores were added together at once.
#So, we've generated the total scores for each of these subtests from each patient, we then correlated these scores with the subtests from the original TASIT
```



```{r}
#Up to this point, all of the correlations have been made across all groups (that is, scores from both patients and controls from TASIT-S are compared with scores from both patients and controls in the original TASIT). In the following chunks, I created correlations between the scores of TASIT:S and TASIT sub-scores only between controls and only between patients
```



```{r}
#Trying to create a correlation matrix between the scores of control group participants only
#First, I need to filter the original dataset in such a way that I can only see the control group scores
control_data <- subset(spinsdata, redcap_event_name == "control_arm_1")
#Could have used "diagnostic_group" variable instead of "redcap_event_name"
print(control_data)
#It worked! When you run this command you will only see the control group data. The patient data has been removed
#Now get the control group scores of the tests that you want to correlate. Let's work with control group scores from TASIT-S:1 and TASIT:1 (total scores of TASIT-S:1 and TASIT:1 of the control groups)

#Note: the next variables I set (controlscores_tasits1 and controlscores_tasit1) actually did not need to be set (so I turned them into notes). Considering that I've already run the spinsdata, set variables, then filtered the data to only show control group data, the original variables (ex: the total tasit-s:1 score) are still applied to this refined dataset. Therefore, I  can now just find the TASIT-S:1 total score for the control patients using the original variable for this total score (which was "tasits_part1_total")

#controlscores_tasits1 <- control_data$tasits_part1_total
#controlscores_tasit1 <- control_data$tasit_part1_total

#Control Group correlations
#---------------------------------------------------------------------------------------------------------------------------------
#Now we can correlate the control's scores from TASIT-S:1 and TASIT:1
cor(na.omit(control_data[c("tasit_part1_total", "tasits_part1_total")]))
#correlation that produces p values:
cor.test(control_data$tasit_part1_total, control_data$tasits_part1_total)
#Spearman's correlation coefficient
cor.test(control_data$tasit_part1_total, control_data$tasits_part1_total,
         method = "spearman", exact = FALSE)


#Correlations for TASIT-S:2 and TASIT:2 scores in controls:
#correlation between TASIT-S:2 and original TASIT:2 total scores:
cor(na.omit(control_data[c("tasit_part2_total", "tasits_part2_total")]))
#correlation that produces p values:
cor.test(control_data$tasit_part2_total, control_data$tasits_part2_total)
#Spearman's correlation coefficient
cor.test(control_data$tasit_part2_total, control_data$tasits_part2_total,
         method = "spearman", exact = FALSE)

#correlation between TASIT-S:2 sincere and TASIT:2 sincere
cor(na.omit(control_data[c("tasit_part2_sinc", "tasits_part2_sinc")]))
#correlation that produces p values:
cor.test(control_data$tasit_part2_sinc, control_data$tasits_part2_sinc)
#Spearman's correlation coefficient
cor.test(control_data$tasit_part2_sinc, control_data$tasits_part2_sinc,
         method = "spearman", exact = FALSE)

#correlation between TASIT-S:2 sarcasm and TASIT:2 sarcasm. But first, you need to code a total score for TASIT:2 sarcasm by adding the paradoxical and the simple sarcasm scores(which I didn't do here as this was originally done in a much earlier chunk using the spinsdata, and as long as we've run that data, everything applies up to here).
cor(na.omit(control_data[c("tasit_part2_sarc", "tasits_part2_sarc")]))
#correlation that produces p values:
cor.test(control_data$tasit_part2_sarc, control_data$tasits_part2_sarc)
#Spearman's correlation coefficient
cor.test(control_data$tasit_part2_sarc, control_data$tasits_part2_sarc,
         method = "spearman", exact = FALSE)


#TASIT-S:3 and TASIT:3 Correlations:
cor(na.omit(control_data[c("tasit_part3_total", "tasits_part3_total")]))
#correlation that produces p values:
cor.test(control_data$tasit_part3_total, control_data$tasits_part3_total)
#Spearman's correlation coefficient
cor.test(control_data$tasit_part3_total, control_data$tasits_part3_total,
         method = "spearman", exact = FALSE)

#Correlating "lies" scores
cor(na.omit(control_data[c("tasits_part3_lies", "tasit_part3_lies")]))
#correlation that produces p values:
cor.test(control_data$tasits_part3_lies, control_data$tasit_part3_lies)
#Spearman's correlation coefficient
cor.test(control_data$tasits_part3_lies, control_data$tasit_part3_lies,
         method = "spearman", exact = FALSE)

#Correlating "sarcasm" scores
cor(na.omit(control_data[c("tasits_part3_sarc", "tasit_part3_sarc")]))
#correlation that produces p values:
cor.test(control_data$tasits_part3_sarc, control_data$tasit_part3_sarc)
#Spearman's correlation coefficient
cor.test(control_data$tasits_part3_sarc, control_data$tasit_part3_sarc,
         method = "spearman", exact = FALSE)
```



```{r}
#Patient correlations - this process follows the exact same steps as what we did with the controls, except we use ONLY patient data
#First, I need to filter the original dataset in such a way that I can only see the patient group scores
patient_data <- subset(spinsdata, redcap_event_name == "case_arm_2")
print(patient_data)

#Patient Group correlations
#---------------------------------------------------------------------------------------------------------------------------------
#Now we can correlate the patient's scores from TASIT-S:1 and TASIT:1
cor(na.omit(patient_data[c("tasit_part1_total", "tasits_part1_total")]))
#correlation that produces p values:
cor.test(patient_data$tasit_part1_total, patient_data$tasits_part1_total)

#Correlations for TASIT-S:2 and TASIT:2 scores in patients:
#correlation between TASIT-S:2 and original TASIT:2 total scores:
cor(na.omit(patient_data[c("tasit_part2_total", "tasits_part2_total")]))
#correlation that produces p values:
cor.test(patient_data$tasit_part2_total, patient_data$tasits_part2_total)
#Spearman's correlation coefficient
cor.test(patient_data$tasit_part2_total, patient_data$tasits_part2_total,
         method = "spearman", exact = FALSE)

#correlation between TASIT-S:2 sincere and TASIT:2 sincere
cor(na.omit(patient_data[c("tasit_part2_sinc", "tasits_part2_sinc")]))
#correlation that produces p values:
cor.test(patient_data$tasit_part2_sinc, patient_data$tasits_part2_sinc)
#Spearman's correlation coefficient
cor.test(patient_data$tasit_part2_sinc, patient_data$tasits_part2_sinc,
         method = "spearman", exact = FALSE)

#correlation between TASIT-S:2 sarcasm and TASIT:2 sarcasm. But first, you need to code a total score for TASIT:2 sarcasm by adding the paradoxical and the simple sarcasm scores(which I didn't do here as this was originally done in a much earlier chunk using the spinsdata, and as long as we've run that data, everything applies up to here).
cor(na.omit(patient_data[c("tasit_part2_sarc", "tasits_part2_sarc")]))
#correlation that produces p values:
cor.test(patient_data$tasit_part2_sarc, patient_data$tasits_part2_sarc)
#Spearman's correlation coefficient
cor.test(patient_data$tasit_part2_sarc, patient_data$tasits_part2_sarc,
         method = "spearman", exact = FALSE)


#TASIT-S:3 and TASIT:3 Correlations:
cor(na.omit(patient_data[c("tasit_part3_total", "tasits_part3_total")]))
#correlation that produces p values:
cor.test(patient_data$tasit_part3_total, patient_data$tasits_part3_total)
#Spearman's correlation coefficient
cor.test(patient_data$tasit_part3_total, patient_data$tasits_part3_total,
         method = "spearman", exact = FALSE)

#Correlating "lies" scores
cor(na.omit(patient_data[c("tasits_part3_lies", "tasit_part3_lies")]))
#correlation that produces p values:
cor.test(patient_data$tasits_part3_lies, patient_data$tasit_part3_lies)
#Spearman's correlation coefficient
cor.test(patient_data$tasits_part3_lies, patient_data$tasit_part3_lies,
         method = "spearman", exact = FALSE)

#Correlating "sarcasm" scores
cor(na.omit(patient_data[c("tasits_part3_sarc", "tasit_part3_sarc")]))
#correlation that produces p values:
cor.test(patient_data$tasits_part3_sarc, patient_data$tasit_part3_sarc)
#Spearman's correlation coefficient
cor.test(patient_data$tasits_part3_sarc, patient_data$tasit_part3_sarc,
         method = "spearman", exact = FALSE)
```



```{r}
#Trying to make a data-set that only contains TASIT:S scores (removing original TASIT scores)
#Run all of the data up to this point so that the total subscore variables for TASIT-S are existing in the dataset (as they should be).
#Can use the following function: This creates a new variable (which is the TASIT-S dataset) that only contains data from the TASIT-S scores. This is done by only including the data from the columns (aka, the specific TASIT:S tests) that we want to see.
tasits_data_only_using_column_numbers <- spinsdata[, c(263, 265, 266, 267, 269, 270,  271)]
print(tasits_data_only_using_column_numbers)
#A much easier way to do this is just by inputting the names of the column that we want to see, instead of their numbers (as finding their numbers is much more tedious). Also, in the command above, I did not include the columns that included the patient ID's (called redcap_event_name). 
tasits_data_only <- spinsdata[, c("record_id", "redcap_event_name", "tasits_part1_total", "tasits_part2_sinc", "tasits_part2_sarc", "tasits_part2_total", "tasits_part3_lies", "tasits_part3_sarc", "tasits_part3_total")]
print(tasits_data_only)
#So now we have a dataset that only contains TASIT-S scores! (basically have a TASIT-S dataset). If you want, you can make a correlation between the original TASIT dataset and the TASIT:S dataset, although the results should not be trusted at all as you should remember that the original TASIT dataset (spinsdata) contains the TASIT-S variables that you created. So the correlations woudl be messed up. You technically can remove the TASIT-S scores from the TASIT data, then make a correlation 
#cor(na.omit(patient_data[c("tasits_data_only", "spinsdata")]))
#Note: this is actually an incorrect command, as when you typically do correlations, they are between variables from one dataset (hence the name "patient_data" before the actual correlations. To do the correlations between different datasets, you would need ot use a different command)

#So instead, I'll make a dataset that only contains original TASIT data
#o.g.tasit_data_only <- 

#You can also make TASIT-S datasets for only controls, and only for patients, which is what you did earlier, but with the original dataset. 
patient_data_tasits <- subset(tasits_data_only, redcap_event_name == "case_arm_2")
control_data_tasits <- subset(tasits_data_only, redcap_event_name == "control_arm_1")
```



```{r}
#Checking to see which patients have messed up TASIT-S scores
tasits_data_only[!complete.cases(tasits_data_only),]
#Checking to see what scores these patients are missing. When doing this step, make sure to rerun the entire script so that participants who were meant to be removed earlier on in the script are removed here as well. To check for each participant, just replace the record ID. We can then remove any of these participants from the original spinsdata, and then rerun the entire script to make sure our correlations are updated
subset(spinsdata, record_id == "SPN01_ZHP_0172")
#The next step is to then remove the participants who are missing data from the dataset, which is done at the beginning of the script.
```



```{r}
#Checking distributions of variables in datasets - only TASIT-S variables and only TASIT variables
#TASIT-S Distributions
#TASIT-S: need to melt data first, as ggplot function only uses long data format

library(ggplot2)
library(reshape)
library(melt)

tasits_distribution <- tasits_data_only[, c(1,3:9)]
tasits_distribution <- melt(tasits_distribution)
print(tasits_distribution)

#Note: we need to melt the dataset because ggplot only uses long format datasets. So we subset the data (select which columns/variables that we want to graph, and then we melt this data. ("ggplot only works with data frames, so we need to convert this matrix into data frame form, with one measurement in each row.")

ggplot(data = tasits_distribution, mapping = aes(x = value)) +
  geom_histogram(bins = 10) + facet_wrap(~variable, scales = 'free_x')

#TASIT Distributions:
#TASIT: Making distributions for variables that were used to make correlations with TASIT-S variables. Need to melt data first, as ggplot function only uses long data format.

tasit_distribution <- spinsdata[, c("record_id", "tasit_part1_total", "tasit_part2_sinc", "tasit_part2_sarc", "tasit_part2_total", "tasit_part3_lies", "tasit_part3_sarc", "tasit_part3_total")]
tasit_distribution <- melt(tasit_distribution)
print(tasit_distribution)

ggplot(data = tasit_distribution, mapping = aes(x = value)) +
  geom_histogram(bins = 10) + facet_wrap(~variable, scales = 'free_x')


#Check for normality using Shapiro-Wilkin's Test:

#Note: for the shapiro test, you cannot use the variable "tasits_distribution" or "tasit_distribution" because you melted these datasets in the code above this, meaning that those variables that you would otherwise be testing normality for, no longer exist in separate columns, but rather all exist under the column "variable" (and now only a few columns exist, rather than all of the columns for the variables). Therefore, use a dataset that has not been melted, and contains the variables that you want to check normality for.
#TASIT-S

#shapiro.test(tasits_data_only$tasits_part1_total)
#shapiro.test(tasits_data_only$tasits_part2_sinc)
#shapiro.test(tasits_data_only$tasits_part2_sarc)
#shapiro.test(tasits_data_only$tasits_part2_total)
#shapiro.test(tasits_data_only$tasits_part3_lies)
#shapiro.test(tasits_data_only$tasits_part3_sarc)
#shapiro.test(tasits_data_only$tasits_part3_total)

#This function is a short cut for what you did above;

apply(tasits_data_only[,3:9], 2, shapiro.test)

#Original TASIT
#Have to use a datset that has not been melted though:
tasit_distribution_shapirotest <- spinsdata[, c("record_id", "tasit_part1_total", "tasit_part2_sinc", "tasit_part2_sarc", "tasit_part2_total", "tasit_part3_lies", "tasit_part3_sarc", "tasit_part3_total")]
apply(tasit_distribution_shapirotest[,2:8], 2, shapiro.test)

#Shapiro-Wilk Test for Normality: If the test is non-significant (p>. 05) it tells us that the distribution of the sample is not significantly different from a normal distribution. If, however, the test is significant (p < . 05) then the distribution in question is significantly different from a normal distribution.
#is this a distribution that includes both diagnostic groups? This doesn't matter here actually. This is because the distributions made in this chunk were done across all groups (didn't segregate any groups)

#Verifying normality:
#can verify for normality in data distributions - for paper: using shapiro test
#function is shapiro.test
#Use shapiro test to check normality of the data. Skip for now, as it is not mandatory
#library("dplyr")
#nstall.packages("ggbupr")
#library("ggpubr")
#apply(spinsdata,2,shapiro.test)
```



```{r}
#Note: A p-value, or probability value, is a number describing how likely it is that your data would have occurred by random chance (i.e. that the null hypothesis is true).

#use bootstrap t test p values - checking if difference in datasets is significant
#T tests in diagnostic groups (controls vs cases)
#What we're doing here is taking TASIT data (one type of TASIT test) from controls, and TASIT data from case participants, and then we are making a T test between these two vectors. This will help us compare the means of variables between two different diagnostic groups.
library(MKinfer)
#Original TASIT T-tests:
boot.t.test(tasit_part1_total ~ diagnostic_group, data=spinsdata, paired=FALSE, R=1000)
boot.t.test(tasit_part2_sinc ~ diagnostic_group, data=spinsdata, paired=FALSE, R=1000)
boot.t.test(tasit_part2_sarc ~ diagnostic_group, data=spinsdata, paired=FALSE, R=1000)
boot.t.test(tasit_part2_total ~ diagnostic_group, data=spinsdata, paired=FALSE, R=1000)
boot.t.test(tasit_part3_lies ~ diagnostic_group, data=spinsdata, paired=FALSE, R=1000)
boot.t.test(tasit_part3_sarc ~ diagnostic_group, data=spinsdata, paired=FALSE, R=1000)
boot.t.test(tasit_part3_total ~ diagnostic_group, data=spinsdata, paired=FALSE, R=1000)
#TASIT-S T-tests:
boot.t.test(tasits_part1_total ~ diagnostic_group, data=spinsdata, paired=FALSE, R=1000)
boot.t.test(tasits_part2_sinc ~ diagnostic_group, data=spinsdata, paired=FALSE, R=1000)
boot.t.test(tasits_part2_sarc ~ diagnostic_group, data=spinsdata, paired=FALSE, R=1000)
boot.t.test(tasits_part2_total ~ diagnostic_group, data=spinsdata, paired=FALSE, R=1000)
boot.t.test(tasits_part3_lies ~ diagnostic_group, data=spinsdata, paired=FALSE, R=1000)
boot.t.test(tasits_part3_sarc ~ diagnostic_group, data=spinsdata, paired=FALSE, R=1000)
boot.t.test(tasits_part3_total ~ diagnostic_group, data=spinsdata, paired=FALSE, R=1000)

#T-tests are done here to see if the original TASIT and TASIT-S subscores show similar differnetiation between our case and control groups (i.e., are similar group differences seen with the orig TASIT and TASIT-S scores, based on the p values and effect sizes)

#T-tests by sex - have to merge datasets first as "spinsdata" dataset does not include sex variable
#merge by record_id = merge datasets by variable record_id (merge "spinsdata" dataset, which contains TASIT data of the participants, and "spins_df" dataset, which contains the social cognitive measures of the participants)
#Merging the datasets:
spins_total_data <- merge(spinsdata,spins_df,by="record_id")
print(spins_total_data)
#Original TASIT T-tests:
boot.t.test(tasit_part1_total ~ demo_sex, data=spins_total_data, paired=FALSE, R=1000)
boot.t.test(tasit_part2_sinc ~ demo_sex, data=spins_total_data, paired=FALSE, R=1000)
boot.t.test(tasit_part2_sarc ~ demo_sex, data=spins_total_data, paired=FALSE, R=1000)
boot.t.test(tasit_part2_total ~ demo_sex, data=spins_total_data, paired=FALSE, R=1000)
boot.t.test(tasit_part3_lies ~ demo_sex, data=spins_total_data, paired=FALSE, R=1000)
boot.t.test(tasit_part3_sarc ~ demo_sex, data=spins_total_data, paired=FALSE, R=1000)
boot.t.test(tasit_part3_total ~ demo_sex, data=spins_total_data, paired=FALSE, R=1000)
#TASIT-S T-tests:
boot.t.test(tasits_part1_total ~ demo_sex, data=spins_total_data, paired=FALSE, R=1000)
boot.t.test(tasits_part2_sinc ~ demo_sex, data=spins_total_data, paired=FALSE, R=1000)
boot.t.test(tasits_part2_sarc ~ demo_sex, data=spins_total_data, paired=FALSE, R=1000)
boot.t.test(tasits_part2_total ~ demo_sex, data=spins_total_data, paired=FALSE, R=1000)
boot.t.test(tasits_part3_lies ~ demo_sex, data=spins_total_data, paired=FALSE, R=1000)
boot.t.test(tasits_part3_sarc ~ demo_sex, data=spins_total_data, paired=FALSE, R=1000)
boot.t.test(tasits_part3_total ~ demo_sex, data=spins_total_data, paired=FALSE, R=1000)

#P-value in T tests will tell you if the differences in the means of the variable being discussed is significantly different between cases and controls


#figure out correct code for finding effect sizes.
#Next: Effect sizes (using cohen's d)
#Original TASIT effect sizes (by diagnostic_group)
library(effsize)
cohen.d(tasit_part1_total ~ diagnostic_group, data=spinsdata)
cohen.d(tasit_part2_sinc ~ diagnostic_group, data=spinsdata)
cohen.d(tasit_part2_sarc ~ diagnostic_group, data=spinsdata)
cohen.d(tasit_part2_total ~ diagnostic_group, data=spinsdata)
cohen.d(tasit_part3_lies ~ diagnostic_group, data=spinsdata)
cohen.d(tasit_part3_sarc ~ diagnostic_group, data=spinsdata)
cohen.d(tasit_part3_total ~ diagnostic_group, data=spinsdata)
#TASIT-S effect sizes (by redcap_id)
cohen.d(tasits_part1_total ~ diagnostic_group, data=spinsdata)
cohen.d(tasits_part2_sinc ~ diagnostic_group, data=spinsdata)
cohen.d(tasits_part2_sarc ~ diagnostic_group, data=spinsdata)
cohen.d(tasits_part2_total ~ diagnostic_group, data=spinsdata)
cohen.d(tasits_part3_lies ~ diagnostic_group, data=spinsdata)
cohen.d(tasits_part3_sarc ~ diagnostic_group, data=spinsdata)
cohen.d(tasits_part3_total ~ diagnostic_group, data=spinsdata)


#Original TASIT effect sizes (by demo_sex)
cohen.d(tasit_part1_total ~ demo_sex, data=spins_total_data)
cohen.d(tasit_part2_sinc ~ demo_sex, data=spins_total_data)
cohen.d(tasit_part2_sarc ~ demo_sex, data=spins_total_data)
cohen.d(tasit_part2_total ~ demo_sex, data=spins_total_data)
cohen.d(tasit_part3_lies ~ demo_sex, data=spins_total_data)
cohen.d(tasit_part3_sarc ~ demo_sex, data=spins_total_data)
cohen.d(tasit_part3_total ~ demo_sex, data=spins_total_data)
#TASIT-S effect sizes (by demo_sex)
cohen.d(tasits_part1_total ~ demo_sex, data=spins_total_data)
cohen.d(tasits_part2_sinc ~ demo_sex, data=spins_total_data)
cohen.d(tasits_part2_sarc ~ demo_sex, data=spins_total_data)
cohen.d(tasits_part2_total ~ demo_sex, data=spins_total_data)
cohen.d(tasits_part3_lies ~ demo_sex, data=spins_total_data)
cohen.d(tasits_part3_sarc ~ demo_sex, data=spins_total_data)
cohen.d(tasits_part3_total ~ demo_sex, data=spins_total_data)

#Cohen's d. Cohen's d is designed for comparing two groups. It takes the difference between two means and expresses it in standard deviation units. It tells you how many standard deviations lie between the two means.

#Note: did not only merge specific variables from spins_df dataset into spinsdata, rather I merged all of the variables from spin_df with spinsdata. You can merge only specific ones later on if you want.
#Merging specific spins_df variables with spinsdata dataset:
#Could also subset spins_df dataset to contain specific variables. Then merge with spinsdata dataset

spins_df_specific <- spins_df[, c("record_id","scog_er40_total", "scog_rmet_total","scog_mean_ea", "scog_iri_perspective", "scog_iri_fantasy", "scog_iri_personal_distress", "scog_iri_empathic_concern", "bsfs_total","qls_total", "np_domain_tscore_process_speed", "np_domain_tscore_att_vigilance", "np_domain_tscore_work_mem", "np_domain_tscore_verbal_learning", "np_domain_tscore_visual_learning", "np_domain_tscore_reasoning_ps", "np_domain_tscore_social_cog", "bprs_factor_total", "sans_total_sc", "demo_age_study_entry")]

spins_total_data_specific <- merge(spinsdata,spins_df_specific,by="record_id")
print(spins_total_data_specific)
```




```{r}
#Making distributions for other social cognitive measures.
#Need to still subset the data because the id variable must be apparent when making distributions, even though all of the variables in this dataset are being graphed.
spins_df_specific <- melt(spins_df_specific)
ggplot(data = spins_df_specific, mapping = aes(x = value)) +
  geom_histogram(bins = 10) + facet_wrap(~variable, scales = 'free_x')

#Checking Normality
#Need to make a dataset that is not melted however:
spins_df_specific_shapirotest <- spins_df[, c("record_id","scog_er40_total", "scog_rmet_total","scog_mean_ea", "scog_iri_perspective", "scog_iri_fantasy", "scog_iri_personal_distress", "scog_iri_empathic_concern", "bsfs_total","qls_total", "np_domain_tscore_process_speed", "np_domain_tscore_att_vigilance", "np_domain_tscore_work_mem", "np_domain_tscore_verbal_learning", "np_domain_tscore_visual_learning", "np_domain_tscore_reasoning_ps", "np_domain_tscore_social_cog", "bprs_factor_total", "sans_total_sc", "demo_sex", "demo_age_study_entry")]

#Checking Normality of distributions
apply(spins_df_specific_shapirotest[,c(2:19,21)], 2, shapiro.test)

# shapiro.test(spins_df_specific_shapirotest$demo_sex) was not included for the shapiro.test as it is a non numeric variable. Was also removed from the original distributions for the same reason. So, "demo_sex" variable was removed from "spins_df_specific" dataset and "spins_df_specific_shapirotest" dataset. Still remained in the original "spins_df" dataset though because this dataset was merged with "spinsdata" datset because T tests were done based on "demo_sex". This way, the correlations for the soc cog data vs TASIT-S data should not include any "demo_sex" correlations (because the dataset used for the correlations does not include "demo_sex").
```



```{r}
# social cognitive measures correlated with TASIT-S variables:
#These correlations are done so that we can compare the TASIT-S scores to some other measures that are related to TASIT. This further tests the validity of the short form of the test
# So that we don't have to do the correlations 1 by 1, we can use the "rcorr" function:
#Note: The as.numeric function in R is used to convert a character vector into a numeric vector.
library("Hmisc")
rcorr(apply(spins_total_data_specific[,c(265:270,272:289)],2, as.numeric))
# Patients only
rcorr(apply(spins_total_data_specific[spins_total_data_specific$diagnostic_group=="case",c(265:270,272:289)],2, as.numeric))
# Controls only (have to remove variables "bprs_factor_total", "sans_total_sc", and "qls_total" from this correlation between controls only, because these measures were only taken in case participants. These variables are column numbers 289, 290, and 281)
rcorr(apply(spins_total_data_specific[spins_total_data_specific$diagnostic_group=="control",c(265:270,272:289)],2, as.numeric))
#Note - "demo_sex" variable was removed from "spins_df_specific" dataset, which is why social cognitive variables included are 273-291 and not 273-292
#Basically doing the first thing you did in this project - make correlations between other soc/cog measures and TASIT-S subtests. Only look at these with the TASIT-S, not the original TASIT
#Issue encountered after running the correlations - NA's. Should I use na.omit? Or should I remove those original individuals who had missing TASIT values.
#filter spins_df for NAs (remove demo_sex category).
```


```{r, fig.width = 4, fig.height = 6}
#Visualizations 

#Creating tables

#Make new spins_df dataset that contains all of the variables that we would like to use for this first table (ex: age, education)
#This new variable "spins_df_table1" contains some new variables as well as all of the variable that are in the "spins_df_specific" dataset

#Table 1 
spins_df_table1 <- spins_df[, c("diagnostic_group", "demo_sex", "demo_age_study_entry", "demo_highest_grade_self", "scog_er40_total", "scog_rmet_total","scog_mean_ea", "scog_iri_perspective", "scog_iri_fantasy", "scog_iri_personal_distress", "scog_iri_empathic_concern", "bsfs_total","qls_total", "np_domain_tscore_process_speed", "np_domain_tscore_att_vigilance", "np_domain_tscore_work_mem", "np_domain_tscore_verbal_learning", "np_domain_tscore_visual_learning", "np_domain_tscore_reasoning_ps", "np_domain_tscore_social_cog", "bprs_factor_total", "sans_total_sc")]
library(tableone)
table1 <- CreateTableOne(data = spins_df_table1[,c(1:22)], strata = c("diagnostic_group"))
print(table1, contDigits = 3)
#table I think I might use instead of table 1 though:
#Table 1 
spins_df_table1_other <- spins_df[, c("diagnostic_group", "demo_sex", "demo_age_study_entry", "demo_highest_grade_self")]
table1other <- CreateTableOne(data = spins_df_table1_other[,c(1:4)], strata = c("diagnostic_group"))
print(table1other, contDigits = 3)

#Table 5 
spinsdata_table5 <- spins_total_data_specific[, c("diagnostic_group", "tasit_part1_total","tasit_part2_sinc", "tasit_part2_sarc", "tasit_part2_total", "tasit_part3_lies", "tasit_part3_sarc", "tasit_part3_total", "tasits_part1_total", "tasits_part2_sinc", "tasits_part2_sarc", "tasits_part2_total", "tasits_part3_lies", "tasits_part3_sarc", "tasits_part3_total")]
table5 <- CreateTableOne(data = spinsdata_table5[,c(1:15)], strata = c("diagnostic_group"))



#Box plot graphs - case vs controls
library(ggplot2)
#Box plots I made were for TASIT and TASIT-S Part 3 Total scores
#TASIT-S box plot
plot1 <- ggplot(spins_total_data_specific, aes(x = diagnostic_group, y = tasits_part3_total, col = diagnostic_group)) +
  # col (or colour) has been specified to represent the diagnostic group
  geom_boxplot() + labs(y = "TASIT-S 3 Total Score", x="Diagnostic Group", colour="Diagnostic Group") +   # can add x and y labels and modify the legend title by specifying 
  scale_x_discrete(breaks=NULL) +
  geom_jitter(shape=16, position=position_jitterdodge()) +
 scale_colour_discrete(labels=c("SSD","Control"))
  # guides(fill=guide_legend(title="Diagnostic Group"))
#TASIT box plot
plot2 <- ggplot(spins_total_data_specific, aes(x = diagnostic_group, y = tasit_part3_total, col = diagnostic_group)) +
  # col (or colour) has been specified to represent the diagnostic group
  geom_boxplot() + labs(y = "TASIT 3 Total Score", x="Diagnostic Group", colour="Diagnostic Group") +   # can add x and y labels and modify the legend title by specifying 
  scale_x_discrete(breaks=NULL) +
  geom_jitter(shape=16, position=position_jitterdodge()) +
 scale_colour_discrete(labels=c("SSD","Control"))

print(plot1)
print(plot2)


#To save these plots as images:  
#ggsave("plot4.png", plot4, dpi=750)
  # guides(fill=guide_legend(title="Diagnostic Group"))
#ggsave("plot4.png", dpi=750)
#?ggsave
#jpeg("/mnt/tigrlab/scratch/aolorunsola/plot4.jpeg", quality = 100)
#### how to save images in higher resolution ####
# print(name_of_your_plot)
# in the bottom right panel click on plots > export
# select "save as image"
# select the 'TIFF' format (instead of 'PNG' for higher resolution)
# check the path and name of your file
```




```{r}
#Some more visualizations:

#Correlation matrix: TASIT vs TASIT-S
library(corrplot)
tasit_data_only <- spinsdata[, c("record_id", "tasit_part1_total", "tasit_part2_sinc", "tasit_part2_sarc", "tasit_part2_total", "tasit_part3_lies", "tasit_part3_sarc", "tasit_part3_total")]
tasits_data_only_1 <- spinsdata[, c("record_id", "tasits_part1_total", "tasits_part2_sinc", "tasits_part2_sarc", "tasits_part2_total", "tasits_part3_lies", "tasits_part3_sarc", "tasits_part3_total")]
#made it tasits_data_only_1 because the original tasits_data_only variable contained the redcap_event variable, which I didnt want in the dataset
#Merging the tasit-s and tasit only datasets, so that we have a dataset that only includes tasit and tasit-s variables that we care about
tasit_tasits_merged <- merge(tasit_data_only,tasits_data_only_1,by="record_id")
#remove redcap_id variable because it is not numeric
tasit_tasits_merged <- tasit_tasits_merged[, c(2:15)]
tasit_tasits_correlation <- cor(tasit_tasits_merged)
corrplot(tl.col = "black", tasit_tasits_correlation, method = 'color')


#Correlation matrix: TASIT-S vs other measures
othercorrelation <- spins_total_data_specific[,c(263,265,266,267,269,270,271,273,274,280)]
othercorrelation <- cor(othercorrelation, use = "complete.obs")
corrplot(tl.col = "black", othercorrelation, method = 'color')




#Scatterplot
#Make a dataset that only includes case data, as for this scatterplot I will be using "sans_total" measurement, which is not found in controls:
patient_data_specific <- subset(spins_total_data_specific, diagnostic_group == "case")
print(patient_data_specific)

library(ggplot2)
ggplot(patient_data_specific, aes(x=tasits_part3_total, y=sans_total_sc)) +
  geom_point() +
  geom_smooth(method="lm", fill = "grey40") +
  labs(x ="TASIT-S Part 3 Total Score",
       y = "Scale for the Assessment of Negative Symptoms Total Score") +
  theme_bw() +
  theme(panel.grid.minor = element_blank(), panel.grid.major = element_blank(),text=element_text(size=14))


#Finding out some more values for scatterplot (r values, spearman's correlations, etc)
#correlation between TASIT-S 3 total score and SANS measure
cor(na.omit(patient_data_specific[c("tasits_part3_total", "sans_total_sc")]))
#can also use "rcorr" function (for multiple variables)
#correlation that produces p values:
cor.test(patient_data_specific$tasits_part3_total, patient_data_specific$sans_total_sc) 
#correlation using spearman's coefficients:
cor.test(patient_data_specific$tasits_part3_total, patient_data_specific$sans_total_sc,
         method = "spearman", exact = FALSE)
```